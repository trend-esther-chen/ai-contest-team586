You are an employee of a software company that offers a flagship product designed to help clients manage device deployment and monitor security events on private networks. The product can automatically discover nodes on these networks and monitor events, even if the nodes don't have the product installed. However, multiple customers have recently complained about hacker attacks, and it was discovered that the devices used for the attacks were not automatically discovered by the product. This led to a lack of detection of abnormal behavior on these devices, making them vulnerable entry points for hackers.

In the product's design, discovered nodes form undirected connections, creating a connectivity graph for data routes and node state monitoring. You've been tasked with manually correcting the existing graph to address recent incidents and product issues.

The database holds information about known nodes, those missed in the incident, and current connections. Connections generated by nodes are stored. Similar connections may be established by different nodes. Without customer authorization for re-discovery, you must analyze the node structure. Node swaps in arbitrary connections are permitted. The goal is to minimize swaps for graph repair. The fixed graph should ensure all nodes are connected. Success means any node can connect to another, directly or indirectly.

You must create a function to automatically identify nodes that can be manually repaired through a series of operations under current conditions and those that cannot be repaired using this method:

```python3
def solution(n: int, connections: list[list[int, int]]) -> int:
    ...
    pass
```
### Input

Your solution function should have two parameters. 

The first parameter `n` is an integer representing the total number of client nodes. The second parameter, `connections`, is an array representing all the connections in the client connectivity graph. Each element in the array is a tuple of the form (a_i, b_i), denoting two connected nodes.

### Output

The output of the solution function should be an integer, indicating the minimum adjustments needed to repair the connectivity graph. If it's not possible to fix, the output should specify the number of additional connections required for manual repair.


### Input Example 

```
n=6, connections=[[0,1],[0,2],[1,2],[1,3],[4,5]]
```

### Output Example

```
1
```

### Explanation

This input can be visualized as the diagram below:

```
0 --- 1     4    
|   / |     |
|  /  |     |
| /   |     |
2     3     5
```

# Constraints
- $1 <= n <= 10^5$
- $1 <= connections.length <= min(n * (n - 1) / 2, 10^5)$
- $connections[i].length == 2$
- $0 <= a_i, bi < n$
- $a_i != b_i$
- No duplicate connections exist
- Each pair of nodes is connected at most once
